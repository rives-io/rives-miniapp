
/* eslint-disable */
/**
 * This file was automatically generated by cartesapp.template_generator.
 * DO NOT MODIFY IT BY HAND. Instead, run the generator,
 */

import { 
    advanceInput, inspect, 
    AdvanceOutput, InspectOptions, AdvanceInputOptions, GraphqlOptions,
    PartialReport as CartesiReport, PartialNotice as CartesiNotice, PartialVoucher as CartesiVoucher, Input as CartesiInput,
    advanceDAppRelay, advanceERC20Deposit, advanceERC721Deposit, advanceEtherDeposit,
    queryNotice, queryReport, queryVoucher
} from "@arthuravianna/cartesi-client";

import { 
    InspectReport, outputGetters
} from "../cartesapp/utils"

import * as indexerIfaces from "../indexer/ifaces";
import * as indexerLib from "../indexer/lib"




interface OutMap {
    [key: string]: CartesiReport | CartesiNotice | CartesiVoucher;
}
type outType = "report" | "notice" | "voucher";
type AdvanceOutputMap = Record<outType,OutMap>

export interface DecodedIndexerOutput {
    data: any[],
    page: number,
    total: number
}

export async function decodeAdvance(
    advanceResult: AdvanceOutput,
    decoder: (data: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport, modelName:string) => any,
    options?:InspectOptions): Promise<any[]>
{
    let input_index:number;
    if (advanceResult.reports.length > 0) {
        input_index = advanceResult.reports[0].input.index;
    } else if (advanceResult.notices.length > 0) {
        input_index = advanceResult.notices[0].input.index;
    } else if (advanceResult.vouchers.length > 0) {
        input_index = advanceResult.vouchers[0].input.index;
    } else {
        // Can't decode outputs (no outputs)
        return [];
    }
    const outMap: AdvanceOutputMap = {report:{},notice:{},voucher:{}};
    for (const report of advanceResult.reports) { outMap.report[report.index] = report }
    for (const notice of advanceResult.notices) { outMap.notice[notice.index] = notice }
    for (const voucher of advanceResult.vouchers) { outMap.voucher[voucher.index] = voucher }

    const indexerOutput: indexerLib.IndexerOutput = await indexerLib.indexerQuery({input_index:input_index},{...options, decode:true, decodeModel:"IndexerOutput"}) as indexerLib.IndexerOutput;

    const outList: any[] = [];
    for (const indOut of indexerOutput.data) {
        outList.push( decoder(outMap[indOut.type as outType][`${indOut.output_index}`],indOut.class_name) );
    }
    return outList
}

// indexer
export async function genericGetOutputs(
    inputData: indexerIfaces.IndexerPayload,
    decoder: (data: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput, modelName:string) => any,
    options?:InspectOptions
):Promise<DecodedIndexerOutput> {
    if (options == undefined) options = {};
    const indexerOutput: indexerLib.IndexerOutput = await indexerLib.indexerQuery(inputData,{...options, decode:true, decodeModel:"IndexerOutput"}) as indexerLib.IndexerOutput;
    const graphqlQueries: Promise<any>[] = [];
    for (const outInd of indexerOutput.data) {
        const graphqlOptions: GraphqlOptions = {cartesiNodeUrl: options.cartesiNodeUrl, inputIndex: outInd.input_index, outputIndex: outInd.output_index};
        graphqlQueries.push(outputGetters[outInd.type](graphqlOptions).then(
            (output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput) => {
                return decoder(output,outInd.class_name);
            }
        ));
    }
    return Promise.all(graphqlQueries).then((data: any[]) => {return {page:indexerOutput.page, total:indexerOutput.total, data:data};});
}

