/* eslint-disable */
/**
 * This file was automatically generated by cartesapp.template_generator.
 * DO NOT MODIFY IT BY HAND. Instead, run the generator,
 */
import { ethers, Signer, ContractReceipt } from "ethers";

import { 
    advanceInput, inspect, 
    AdvanceOutput, InspectOptions, AdvanceInputOptions, GraphqlOptions,
    EtherDepositOptions, ERC20DepositOptions, ERC721DepositOptions,
    Report as CartesiReport, Notice as CartesiNotice, Voucher as CartesiVoucher, Input as CartesiInput,
    advanceDAppRelay, advanceERC20Deposit, advanceERC721Deposit, advanceEtherDeposit,
    queryNotice, queryReport, queryVoucher
} from "@arthuravianna/cartesi-client";


import Ajv from "ajv"
import addFormats from "ajv-formats"

import { 
    genericAdvanceInput, genericInspect, IOType, Models,
    IOData, Input, Output, Event, ContractCall, InspectReport, 
    MutationOptions, QueryOptions, 
    CONVENTIONAL_TYPES, decodeToConventionalTypes
} from "../cartesapp/utils"

import { 
    genericGetOutputs, decodeAdvance, DecodedIndexerOutput
} from "../cartesapp/lib"

import * as indexerIfaces from "../indexer/ifaces"
import * as ifaces from "./ifaces";


/**
 * Configs
 */

const ajv = new Ajv();
addFormats(ajv);
ajv.addFormat("biginteger", (data) => {
    const dataTovalidate = data.startsWith('-') ? data.substring(1) : data;
    return ethers.utils.isHexString(dataTovalidate) && dataTovalidate.length % 2 == 0;
});
const MAX_SPLITTABLE_OUTPUT_SIZE = 4194247;

/*
 * Mutations/Advances
 */

export async function insertCartridge(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.InsertCartridgePayloadProxy,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: InsertCartridgePayloadProxy = new InsertCartridgePayloadProxy(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.InsertCartridgePayloadProxy>(client,dappAddress,'0x5eab7461',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function setUnlockCartridge(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.SetUnlockedCartridgePayloadProxy,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: SetUnlockedCartridgePayloadProxy = new SetUnlockedCartridgePayloadProxy(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.SetUnlockedCartridgePayloadProxy>(client,dappAddress,'0xdbc5715b',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function insertAndUnlockCartridge(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.InsertCartridgePayloadProxy,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: InsertCartridgePayloadProxy = new InsertCartridgePayloadProxy(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.InsertCartridgePayloadProxy>(client,dappAddress,'0xe05d2b0b',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function removeCartridge(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.RemoveCartridgePayloadProxy,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: RemoveCartridgePayloadProxy = new RemoveCartridgePayloadProxy(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.RemoveCartridgePayloadProxy>(client,dappAddress,'0x436046ac',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function transferCartridge(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.TransferCartridgePayloadProxy,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: TransferCartridgePayloadProxy = new TransferCartridgePayloadProxy(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.TransferCartridgePayloadProxy>(client,dappAddress,'0x0f38d9d7',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function createRule(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.RuleDataProxy,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: RuleDataProxy = new RuleDataProxy(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.RuleDataProxy>(client,dappAddress,'0xf65ad264',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function deactivateRule(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.DeactivateRulePayloadProxy,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: DeactivateRulePayloadProxy = new DeactivateRulePayloadProxy(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.DeactivateRulePayloadProxy>(client,dappAddress,'0x7db38ba8',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function verify(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.VerifyPayloadProxy,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: VerifyPayloadProxy = new VerifyPayloadProxy(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.VerifyPayloadProxy>(client,dappAddress,'0xdb690895',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function registerExternalVerification(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.VerifyPayloadProxy,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: VerifyPayloadProxy = new VerifyPayloadProxy(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.VerifyPayloadProxy>(client,dappAddress,'0xa98dfd7f',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function externalVerification(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.ExternalVerificationPayloadProxy,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: ExternalVerificationPayloadProxy = new ExternalVerificationPayloadProxy(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.ExternalVerificationPayloadProxy>(client,dappAddress,'0x4252da70',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function awardWinners(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.AwardWinnerTapesPayloadProxy,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: AwardWinnerTapesPayloadProxy = new AwardWinnerTapesPayloadProxy(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.AwardWinnerTapesPayloadProxy>(client,dappAddress,'0xb07b85a5',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function cleanTapes(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.CleanTapesPayloadProxy,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: CleanTapesPayloadProxy = new CleanTapesPayloadProxy(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.CleanTapesPayloadProxy>(client,dappAddress,'0x9ab37ddf',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function setOperatorAddress(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.SetOperatorPayload,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: SetOperatorPayload = new SetOperatorPayload(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.SetOperatorPayload>(client,dappAddress,'0xe1e9bc95',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function setInternalVerifyLock(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.SetLock,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: SetLock = new SetLock(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.SetLock>(client,dappAddress,'0xef53291f',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function setCartridgeModerationLock(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.SetLock,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: SetLock = new SetLock(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.SetLock>(client,dappAddress,'0x8328ca15',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function setMaxLockedCartridges(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.SetMaxLockedCartridges,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: SetMaxLockedCartridges = new SetMaxLockedCartridges(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.SetMaxLockedCartridges>(client,dappAddress,'0x6c265c4c',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}

export async function updateRivos(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.UpdateRivosPayload,
    options?:MutationOptions
):Promise<AdvanceOutput|ContractReceipt|any[]> {
    const data: UpdateRivosPayload = new UpdateRivosPayload(inputData);
    if (options?.decode) { options.sync = true; }
    const result = await genericAdvanceInput<ifaces.UpdateRivosPayload>(client,dappAddress,'0x062965bb',data, options)
    if (options?.decode) {
        return decodeAdvance(result as AdvanceOutput,decodeToModel,options);
    }
    return result;
}


/*
 * Queries/Inspects
 */

export async function cartridge(
    inputData: ifaces.CartridgePayloadSplittable,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/cartridge';
    let part:number = 0;
    let hasMoreParts:boolean = false;
    const output: InspectReport = {payload: "0x"}
    do {
        hasMoreParts = false;
        let inputDataSplittable = Object.assign({part},inputData);
        const data: CartridgePayloadSplittable = new CartridgePayloadSplittable(inputDataSplittable);
        const partOutput: InspectReport = await genericInspect<ifaces.CartridgePayloadSplittable>(data,route,options);
        let payloadHex = partOutput.payload.substring(2);
        if (payloadHex.length/2 > MAX_SPLITTABLE_OUTPUT_SIZE) {
            part++;
            payloadHex = payloadHex.substring(0, payloadHex.length - 2);
            hasMoreParts = true;
        }
        output.payload += payloadHex;
    } while (hasMoreParts)
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}

export async function cartridgeInfo(
    inputData: ifaces.CartridgePayload,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/cartridge_info';
    const data: CartridgePayload = new CartridgePayload(inputData);
    const output: InspectReport = await genericInspect<ifaces.CartridgePayload>(data,route,options);
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}

export async function cartridges(
    inputData: ifaces.CartridgesPayload,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/cartridges';
    const data: CartridgesPayload = new CartridgesPayload(inputData);
    const output: InspectReport = await genericInspect<ifaces.CartridgesPayload>(data,route,options);
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}

export async function cartridgeTags(
    inputData: ifaces.GetCartridgeTagsPayload,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/cartridge_tags';
    const data: GetCartridgeTagsPayload = new GetCartridgeTagsPayload(inputData);
    const output: InspectReport = await genericInspect<ifaces.GetCartridgeTagsPayload>(data,route,options);
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}

export async function cartridgeAuthors(
    inputData: ifaces.GetCartridgeAuthorsPayload,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/cartridge_authors';
    const data: GetCartridgeAuthorsPayload = new GetCartridgeAuthorsPayload(inputData);
    const output: InspectReport = await genericInspect<ifaces.GetCartridgeAuthorsPayload>(data,route,options);
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}

export async function rules(
    inputData: ifaces.GetRulesPayload,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/rules';
    const data: GetRulesPayload = new GetRulesPayload(inputData);
    const output: InspectReport = await genericInspect<ifaces.GetRulesPayload>(data,route,options);
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}

export async function ruleTags(
    inputData: ifaces.GetRuleTagsPayload,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/rule_tags';
    const data: GetRuleTagsPayload = new GetRuleTagsPayload(inputData);
    const output: InspectReport = await genericInspect<ifaces.GetRuleTagsPayload>(data,route,options);
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}

export async function tapes(
    inputData: ifaces.GetTapesPayload,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/tapes';
    const data: GetTapesPayload = new GetTapesPayload(inputData);
    const output: InspectReport = await genericInspect<ifaces.GetTapesPayload>(data,route,options);
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}

export async function formatInCard(
    inputData: ifaces.FormatInCardPayload,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/format_in_card';
    const data: FormatInCardPayload = new FormatInCardPayload(inputData);
    const output: InspectReport = await genericInspect<ifaces.FormatInCardPayload>(data,route,options);
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}

export async function operatorAddress(
    inputData: ifaces.EmptyClass,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/operator_address';
    const data: EmptyClass = new EmptyClass(inputData);
    const output: InspectReport = await genericInspect<ifaces.EmptyClass>(data,route,options);
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}

export async function adminAddress(
    inputData: ifaces.EmptyClass,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/admin_address';
    const data: EmptyClass = new EmptyClass(inputData);
    const output: InspectReport = await genericInspect<ifaces.EmptyClass>(data,route,options);
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}

export async function proxyAddress(
    inputData: ifaces.EmptyClass,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/proxy_address';
    const data: EmptyClass = new EmptyClass(inputData);
    const output: InspectReport = await genericInspect<ifaces.EmptyClass>(data,route,options);
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}

export async function config(
    inputData: ifaces.EmptyClass,
    options?:QueryOptions
):Promise<InspectReport|any> {
    const route = 'core/config';
    const data: EmptyClass = new EmptyClass(inputData);
    const output: InspectReport = await genericInspect<ifaces.EmptyClass>(data,route,options);
    if (options?.decode) { return decodeToModel(output,options.decodeModel || "json"); }
    return output;
}


/*
 * Indexer Query
 */

export async function getOutputs(
    inputData: indexerIfaces.IndexerPayload,
    options?:InspectOptions
):Promise<DecodedIndexerOutput> {
    return genericGetOutputs(inputData,decodeToModel,options);
}


/**
 * Models Decoders/Exporters
 */

export function decodeToModel(data: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput, modelName: string): any {
    if (modelName == undefined)
        throw new Error("undefined model");
    if (CONVENTIONAL_TYPES.includes(modelName))
        return decodeToConventionalTypes(data.payload,modelName);
    const decoder = models[modelName].decoder;
    if (decoder == undefined)
        throw new Error("undefined decoder");
    return decoder(data);
}

export function exportToModel(data: any, modelName: string): string {
    const exporter = models[modelName].exporter;
    if (exporter == undefined)
        throw new Error("undefined exporter");
    return exporter(data);
}

export class InsertCartridgePayloadProxyInput extends Input<ifaces.InsertCartridgePayloadProxy> { constructor(data: CartesiInput) { super(models['InsertCartridgePayloadProxy'],data,true); } }
export function decodeToInsertCartridgePayloadProxyInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): InsertCartridgePayloadProxyInput {
    return new InsertCartridgePayloadProxyInput(output as CartesiInput);
}

export class InsertCartridgePayloadProxy extends IOData<ifaces.InsertCartridgePayloadProxy> { constructor(data: ifaces.InsertCartridgePayloadProxy, validate: boolean = true) { super(models['InsertCartridgePayloadProxy'],data,validate); } }
export function exportToInsertCartridgePayloadProxy(data: ifaces.InsertCartridgePayloadProxy): string {
    const dataToExport: InsertCartridgePayloadProxy = new InsertCartridgePayloadProxy(data);
    return dataToExport.export();
}
export class SetUnlockedCartridgePayloadProxyInput extends Input<ifaces.SetUnlockedCartridgePayloadProxy> { constructor(data: CartesiInput) { super(models['SetUnlockedCartridgePayloadProxy'],data,true); } }
export function decodeToSetUnlockedCartridgePayloadProxyInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): SetUnlockedCartridgePayloadProxyInput {
    return new SetUnlockedCartridgePayloadProxyInput(output as CartesiInput);
}

export class SetUnlockedCartridgePayloadProxy extends IOData<ifaces.SetUnlockedCartridgePayloadProxy> { constructor(data: ifaces.SetUnlockedCartridgePayloadProxy, validate: boolean = true) { super(models['SetUnlockedCartridgePayloadProxy'],data,validate); } }
export function exportToSetUnlockedCartridgePayloadProxy(data: ifaces.SetUnlockedCartridgePayloadProxy): string {
    const dataToExport: SetUnlockedCartridgePayloadProxy = new SetUnlockedCartridgePayloadProxy(data);
    return dataToExport.export();
}
export class RemoveCartridgePayloadProxyInput extends Input<ifaces.RemoveCartridgePayloadProxy> { constructor(data: CartesiInput) { super(models['RemoveCartridgePayloadProxy'],data,true); } }
export function decodeToRemoveCartridgePayloadProxyInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): RemoveCartridgePayloadProxyInput {
    return new RemoveCartridgePayloadProxyInput(output as CartesiInput);
}

export class RemoveCartridgePayloadProxy extends IOData<ifaces.RemoveCartridgePayloadProxy> { constructor(data: ifaces.RemoveCartridgePayloadProxy, validate: boolean = true) { super(models['RemoveCartridgePayloadProxy'],data,validate); } }
export function exportToRemoveCartridgePayloadProxy(data: ifaces.RemoveCartridgePayloadProxy): string {
    const dataToExport: RemoveCartridgePayloadProxy = new RemoveCartridgePayloadProxy(data);
    return dataToExport.export();
}
export class TransferCartridgePayloadProxyInput extends Input<ifaces.TransferCartridgePayloadProxy> { constructor(data: CartesiInput) { super(models['TransferCartridgePayloadProxy'],data,true); } }
export function decodeToTransferCartridgePayloadProxyInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): TransferCartridgePayloadProxyInput {
    return new TransferCartridgePayloadProxyInput(output as CartesiInput);
}

export class TransferCartridgePayloadProxy extends IOData<ifaces.TransferCartridgePayloadProxy> { constructor(data: ifaces.TransferCartridgePayloadProxy, validate: boolean = true) { super(models['TransferCartridgePayloadProxy'],data,validate); } }
export function exportToTransferCartridgePayloadProxy(data: ifaces.TransferCartridgePayloadProxy): string {
    const dataToExport: TransferCartridgePayloadProxy = new TransferCartridgePayloadProxy(data);
    return dataToExport.export();
}
export class RuleDataProxyInput extends Input<ifaces.RuleDataProxy> { constructor(data: CartesiInput) { super(models['RuleDataProxy'],data,true); } }
export function decodeToRuleDataProxyInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): RuleDataProxyInput {
    return new RuleDataProxyInput(output as CartesiInput);
}

export class RuleDataProxy extends IOData<ifaces.RuleDataProxy> { constructor(data: ifaces.RuleDataProxy, validate: boolean = true) { super(models['RuleDataProxy'],data,validate); } }
export function exportToRuleDataProxy(data: ifaces.RuleDataProxy): string {
    const dataToExport: RuleDataProxy = new RuleDataProxy(data);
    return dataToExport.export();
}
export class DeactivateRulePayloadProxyInput extends Input<ifaces.DeactivateRulePayloadProxy> { constructor(data: CartesiInput) { super(models['DeactivateRulePayloadProxy'],data,true); } }
export function decodeToDeactivateRulePayloadProxyInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): DeactivateRulePayloadProxyInput {
    return new DeactivateRulePayloadProxyInput(output as CartesiInput);
}

export class DeactivateRulePayloadProxy extends IOData<ifaces.DeactivateRulePayloadProxy> { constructor(data: ifaces.DeactivateRulePayloadProxy, validate: boolean = true) { super(models['DeactivateRulePayloadProxy'],data,validate); } }
export function exportToDeactivateRulePayloadProxy(data: ifaces.DeactivateRulePayloadProxy): string {
    const dataToExport: DeactivateRulePayloadProxy = new DeactivateRulePayloadProxy(data);
    return dataToExport.export();
}
export class VerifyPayloadProxyInput extends Input<ifaces.VerifyPayloadProxy> { constructor(data: CartesiInput) { super(models['VerifyPayloadProxy'],data,true); } }
export function decodeToVerifyPayloadProxyInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): VerifyPayloadProxyInput {
    return new VerifyPayloadProxyInput(output as CartesiInput);
}

export class VerifyPayloadProxy extends IOData<ifaces.VerifyPayloadProxy> { constructor(data: ifaces.VerifyPayloadProxy, validate: boolean = true) { super(models['VerifyPayloadProxy'],data,validate); } }
export function exportToVerifyPayloadProxy(data: ifaces.VerifyPayloadProxy): string {
    const dataToExport: VerifyPayloadProxy = new VerifyPayloadProxy(data);
    return dataToExport.export();
}
export class ExternalVerificationPayloadProxyInput extends Input<ifaces.ExternalVerificationPayloadProxy> { constructor(data: CartesiInput) { super(models['ExternalVerificationPayloadProxy'],data,true); } }
export function decodeToExternalVerificationPayloadProxyInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): ExternalVerificationPayloadProxyInput {
    return new ExternalVerificationPayloadProxyInput(output as CartesiInput);
}

export class ExternalVerificationPayloadProxy extends IOData<ifaces.ExternalVerificationPayloadProxy> { constructor(data: ifaces.ExternalVerificationPayloadProxy, validate: boolean = true) { super(models['ExternalVerificationPayloadProxy'],data,validate); } }
export function exportToExternalVerificationPayloadProxy(data: ifaces.ExternalVerificationPayloadProxy): string {
    const dataToExport: ExternalVerificationPayloadProxy = new ExternalVerificationPayloadProxy(data);
    return dataToExport.export();
}
export class AwardWinnerTapesPayloadProxyInput extends Input<ifaces.AwardWinnerTapesPayloadProxy> { constructor(data: CartesiInput) { super(models['AwardWinnerTapesPayloadProxy'],data,true); } }
export function decodeToAwardWinnerTapesPayloadProxyInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): AwardWinnerTapesPayloadProxyInput {
    return new AwardWinnerTapesPayloadProxyInput(output as CartesiInput);
}

export class AwardWinnerTapesPayloadProxy extends IOData<ifaces.AwardWinnerTapesPayloadProxy> { constructor(data: ifaces.AwardWinnerTapesPayloadProxy, validate: boolean = true) { super(models['AwardWinnerTapesPayloadProxy'],data,validate); } }
export function exportToAwardWinnerTapesPayloadProxy(data: ifaces.AwardWinnerTapesPayloadProxy): string {
    const dataToExport: AwardWinnerTapesPayloadProxy = new AwardWinnerTapesPayloadProxy(data);
    return dataToExport.export();
}
export class CleanTapesPayloadProxyInput extends Input<ifaces.CleanTapesPayloadProxy> { constructor(data: CartesiInput) { super(models['CleanTapesPayloadProxy'],data,true); } }
export function decodeToCleanTapesPayloadProxyInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): CleanTapesPayloadProxyInput {
    return new CleanTapesPayloadProxyInput(output as CartesiInput);
}

export class CleanTapesPayloadProxy extends IOData<ifaces.CleanTapesPayloadProxy> { constructor(data: ifaces.CleanTapesPayloadProxy, validate: boolean = true) { super(models['CleanTapesPayloadProxy'],data,validate); } }
export function exportToCleanTapesPayloadProxy(data: ifaces.CleanTapesPayloadProxy): string {
    const dataToExport: CleanTapesPayloadProxy = new CleanTapesPayloadProxy(data);
    return dataToExport.export();
}
export class SetOperatorPayloadInput extends Input<ifaces.SetOperatorPayload> { constructor(data: CartesiInput) { super(models['SetOperatorPayload'],data); } }
export function decodeToSetOperatorPayloadInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): SetOperatorPayloadInput {
    return new SetOperatorPayloadInput(output as CartesiInput);
}

export class SetOperatorPayload extends IOData<ifaces.SetOperatorPayload> { constructor(data: ifaces.SetOperatorPayload, validate: boolean = true) { super(models['SetOperatorPayload'],data,validate); } }
export function exportToSetOperatorPayload(data: ifaces.SetOperatorPayload): string {
    const dataToExport: SetOperatorPayload = new SetOperatorPayload(data);
    return dataToExport.export();
}
export class SetLockInput extends Input<ifaces.SetLock> { constructor(data: CartesiInput) { super(models['SetLock'],data); } }
export function decodeToSetLockInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): SetLockInput {
    return new SetLockInput(output as CartesiInput);
}

export class SetLock extends IOData<ifaces.SetLock> { constructor(data: ifaces.SetLock, validate: boolean = true) { super(models['SetLock'],data,validate); } }
export function exportToSetLock(data: ifaces.SetLock): string {
    const dataToExport: SetLock = new SetLock(data);
    return dataToExport.export();
}
export class SetMaxLockedCartridgesInput extends Input<ifaces.SetMaxLockedCartridges> { constructor(data: CartesiInput) { super(models['SetMaxLockedCartridges'],data); } }
export function decodeToSetMaxLockedCartridgesInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): SetMaxLockedCartridgesInput {
    return new SetMaxLockedCartridgesInput(output as CartesiInput);
}

export class SetMaxLockedCartridges extends IOData<ifaces.SetMaxLockedCartridges> { constructor(data: ifaces.SetMaxLockedCartridges, validate: boolean = true) { super(models['SetMaxLockedCartridges'],data,validate); } }
export function exportToSetMaxLockedCartridges(data: ifaces.SetMaxLockedCartridges): string {
    const dataToExport: SetMaxLockedCartridges = new SetMaxLockedCartridges(data);
    return dataToExport.export();
}
export class UpdateRivosPayloadInput extends Input<ifaces.UpdateRivosPayload> { constructor(data: CartesiInput) { super(models['UpdateRivosPayload'],data); } }
export function decodeToUpdateRivosPayloadInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): UpdateRivosPayloadInput {
    return new UpdateRivosPayloadInput(output as CartesiInput);
}

export class UpdateRivosPayload extends IOData<ifaces.UpdateRivosPayload> { constructor(data: ifaces.UpdateRivosPayload, validate: boolean = true) { super(models['UpdateRivosPayload'],data,validate); } }
export function exportToUpdateRivosPayload(data: ifaces.UpdateRivosPayload): string {
    const dataToExport: UpdateRivosPayload = new UpdateRivosPayload(data);
    return dataToExport.export();
}
export class CartridgePayloadSplittableInput extends Input<ifaces.CartridgePayloadSplittable> { constructor(data: CartesiInput) { super(models['CartridgePayloadSplittable'],data); } }
export function decodeToCartridgePayloadSplittableInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): CartridgePayloadSplittableInput {
    return new CartridgePayloadSplittableInput(output as CartesiInput);
}

export class CartridgePayloadSplittable extends IOData<ifaces.CartridgePayloadSplittable> { constructor(data: ifaces.CartridgePayloadSplittable, validate: boolean = true) { super(models['CartridgePayloadSplittable'],data,validate); } }
export function exportToCartridgePayloadSplittable(data: ifaces.CartridgePayloadSplittable): string {
    const dataToExport: CartridgePayloadSplittable = new CartridgePayloadSplittable(data);
    return dataToExport.export();
}
export class CartridgePayloadInput extends Input<ifaces.CartridgePayload> { constructor(data: CartesiInput) { super(models['CartridgePayload'],data); } }
export function decodeToCartridgePayloadInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): CartridgePayloadInput {
    return new CartridgePayloadInput(output as CartesiInput);
}

export class CartridgePayload extends IOData<ifaces.CartridgePayload> { constructor(data: ifaces.CartridgePayload, validate: boolean = true) { super(models['CartridgePayload'],data,validate); } }
export function exportToCartridgePayload(data: ifaces.CartridgePayload): string {
    const dataToExport: CartridgePayload = new CartridgePayload(data);
    return dataToExport.export();
}
export class CartridgesPayloadInput extends Input<ifaces.CartridgesPayload> { constructor(data: CartesiInput) { super(models['CartridgesPayload'],data); } }
export function decodeToCartridgesPayloadInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): CartridgesPayloadInput {
    return new CartridgesPayloadInput(output as CartesiInput);
}

export class CartridgesPayload extends IOData<ifaces.CartridgesPayload> { constructor(data: ifaces.CartridgesPayload, validate: boolean = true) { super(models['CartridgesPayload'],data,validate); } }
export function exportToCartridgesPayload(data: ifaces.CartridgesPayload): string {
    const dataToExport: CartridgesPayload = new CartridgesPayload(data);
    return dataToExport.export();
}
export class GetCartridgeTagsPayloadInput extends Input<ifaces.GetCartridgeTagsPayload> { constructor(data: CartesiInput) { super(models['GetCartridgeTagsPayload'],data); } }
export function decodeToGetCartridgeTagsPayloadInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): GetCartridgeTagsPayloadInput {
    return new GetCartridgeTagsPayloadInput(output as CartesiInput);
}

export class GetCartridgeTagsPayload extends IOData<ifaces.GetCartridgeTagsPayload> { constructor(data: ifaces.GetCartridgeTagsPayload, validate: boolean = true) { super(models['GetCartridgeTagsPayload'],data,validate); } }
export function exportToGetCartridgeTagsPayload(data: ifaces.GetCartridgeTagsPayload): string {
    const dataToExport: GetCartridgeTagsPayload = new GetCartridgeTagsPayload(data);
    return dataToExport.export();
}
export class GetCartridgeAuthorsPayloadInput extends Input<ifaces.GetCartridgeAuthorsPayload> { constructor(data: CartesiInput) { super(models['GetCartridgeAuthorsPayload'],data); } }
export function decodeToGetCartridgeAuthorsPayloadInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): GetCartridgeAuthorsPayloadInput {
    return new GetCartridgeAuthorsPayloadInput(output as CartesiInput);
}

export class GetCartridgeAuthorsPayload extends IOData<ifaces.GetCartridgeAuthorsPayload> { constructor(data: ifaces.GetCartridgeAuthorsPayload, validate: boolean = true) { super(models['GetCartridgeAuthorsPayload'],data,validate); } }
export function exportToGetCartridgeAuthorsPayload(data: ifaces.GetCartridgeAuthorsPayload): string {
    const dataToExport: GetCartridgeAuthorsPayload = new GetCartridgeAuthorsPayload(data);
    return dataToExport.export();
}
export class GetRulesPayloadInput extends Input<ifaces.GetRulesPayload> { constructor(data: CartesiInput) { super(models['GetRulesPayload'],data); } }
export function decodeToGetRulesPayloadInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): GetRulesPayloadInput {
    return new GetRulesPayloadInput(output as CartesiInput);
}

export class GetRulesPayload extends IOData<ifaces.GetRulesPayload> { constructor(data: ifaces.GetRulesPayload, validate: boolean = true) { super(models['GetRulesPayload'],data,validate); } }
export function exportToGetRulesPayload(data: ifaces.GetRulesPayload): string {
    const dataToExport: GetRulesPayload = new GetRulesPayload(data);
    return dataToExport.export();
}
export class GetRuleTagsPayloadInput extends Input<ifaces.GetRuleTagsPayload> { constructor(data: CartesiInput) { super(models['GetRuleTagsPayload'],data); } }
export function decodeToGetRuleTagsPayloadInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): GetRuleTagsPayloadInput {
    return new GetRuleTagsPayloadInput(output as CartesiInput);
}

export class GetRuleTagsPayload extends IOData<ifaces.GetRuleTagsPayload> { constructor(data: ifaces.GetRuleTagsPayload, validate: boolean = true) { super(models['GetRuleTagsPayload'],data,validate); } }
export function exportToGetRuleTagsPayload(data: ifaces.GetRuleTagsPayload): string {
    const dataToExport: GetRuleTagsPayload = new GetRuleTagsPayload(data);
    return dataToExport.export();
}
export class GetTapesPayloadInput extends Input<ifaces.GetTapesPayload> { constructor(data: CartesiInput) { super(models['GetTapesPayload'],data); } }
export function decodeToGetTapesPayloadInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): GetTapesPayloadInput {
    return new GetTapesPayloadInput(output as CartesiInput);
}

export class GetTapesPayload extends IOData<ifaces.GetTapesPayload> { constructor(data: ifaces.GetTapesPayload, validate: boolean = true) { super(models['GetTapesPayload'],data,validate); } }
export function exportToGetTapesPayload(data: ifaces.GetTapesPayload): string {
    const dataToExport: GetTapesPayload = new GetTapesPayload(data);
    return dataToExport.export();
}
export class FormatInCardPayloadInput extends Input<ifaces.FormatInCardPayload> { constructor(data: CartesiInput) { super(models['FormatInCardPayload'],data); } }
export function decodeToFormatInCardPayloadInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): FormatInCardPayloadInput {
    return new FormatInCardPayloadInput(output as CartesiInput);
}

export class FormatInCardPayload extends IOData<ifaces.FormatInCardPayload> { constructor(data: ifaces.FormatInCardPayload, validate: boolean = true) { super(models['FormatInCardPayload'],data,validate); } }
export function exportToFormatInCardPayload(data: ifaces.FormatInCardPayload): string {
    const dataToExport: FormatInCardPayload = new FormatInCardPayload(data);
    return dataToExport.export();
}
export class EmptyClassInput extends Input<ifaces.EmptyClass> { constructor(data: CartesiInput) { super(models['EmptyClass'],data); } }
export function decodeToEmptyClassInput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): EmptyClassInput {
    return new EmptyClassInput(output as CartesiInput);
}

export class EmptyClass extends IOData<ifaces.EmptyClass> { constructor(data: ifaces.EmptyClass, validate: boolean = true) { super(models['EmptyClass'],data,validate); } }
export function exportToEmptyClass(data: ifaces.EmptyClass): string {
    const dataToExport: EmptyClass = new EmptyClass(data);
    return dataToExport.export();
}
export class CartridgeInfo extends Output<ifaces.CartridgeInfo> { constructor(output: CartesiReport | InspectReport) { super(models['CartridgeInfo'],output); } }
export function decodeToCartridgeInfo(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): CartridgeInfo {
    return new CartridgeInfo(output as CartesiReport);
}

export class CartridgesOutput extends Output<ifaces.CartridgesOutput> { constructor(output: CartesiReport | InspectReport) { super(models['CartridgesOutput'],output); } }
export function decodeToCartridgesOutput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): CartridgesOutput {
    return new CartridgesOutput(output as CartesiReport);
}

export class CartridgeTagsOutput extends Output<ifaces.CartridgeTagsOutput> { constructor(output: CartesiReport | InspectReport) { super(models['CartridgeTagsOutput'],output); } }
export function decodeToCartridgeTagsOutput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): CartridgeTagsOutput {
    return new CartridgeTagsOutput(output as CartesiReport);
}

export class CartridgeAuthorsOutput extends Output<ifaces.CartridgeAuthorsOutput> { constructor(output: CartesiReport | InspectReport) { super(models['CartridgeAuthorsOutput'],output); } }
export function decodeToCartridgeAuthorsOutput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): CartridgeAuthorsOutput {
    return new CartridgeAuthorsOutput(output as CartesiReport);
}

export class RulesOutput extends Output<ifaces.RulesOutput> { constructor(output: CartesiReport | InspectReport) { super(models['RulesOutput'],output); } }
export function decodeToRulesOutput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): RulesOutput {
    return new RulesOutput(output as CartesiReport);
}

export class RuleTagsOutput extends Output<ifaces.RuleTagsOutput> { constructor(output: CartesiReport | InspectReport) { super(models['RuleTagsOutput'],output); } }
export function decodeToRuleTagsOutput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): RuleTagsOutput {
    return new RuleTagsOutput(output as CartesiReport);
}

export class TapesOutput extends Output<ifaces.TapesOutput> { constructor(output: CartesiReport | InspectReport) { super(models['TapesOutput'],output); } }
export function decodeToTapesOutput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): TapesOutput {
    return new TapesOutput(output as CartesiReport);
}

export class CartridgeEvent extends Event<ifaces.CartridgeEvent> { constructor(output: CartesiNotice) { super(models['CartridgeEvent'],output); } }
export function decodeToCartridgeEvent(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): CartridgeEvent {
    return new CartridgeEvent(output as CartesiNotice);
}

export class CartridgeRemoved extends Event<ifaces.CartridgeRemoved> { constructor(output: CartesiNotice) { super(models['CartridgeRemoved'],output); } }
export function decodeToCartridgeRemoved(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): CartridgeRemoved {
    return new CartridgeRemoved(output as CartesiNotice);
}

export class RuleCreated extends Event<ifaces.RuleCreated> { constructor(output: CartesiNotice) { super(models['RuleCreated'],output); } }
export function decodeToRuleCreated(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): RuleCreated {
    return new RuleCreated(output as CartesiNotice);
}

export class VerificationOutput extends Event<ifaces.VerificationOutput> { constructor(output: CartesiNotice) { super(models['VerificationOutput'],output); } }
export function decodeToVerificationOutput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): VerificationOutput {
    return new VerificationOutput(output as CartesiNotice);
}

export class TapeAward extends Event<ifaces.TapeAward> { constructor(output: CartesiNotice) { super(models['TapeAward'],output); } }
export function decodeToTapeAward(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): TapeAward {
    return new TapeAward(output as CartesiNotice);
}


/**
 * Model
 */

export const models: Models = {
    'InsertCartridgePayloadProxy': {
        ioType:IOType.mutationPayload,
        abiTypes:['bytes'],
        params:['data'],
        decoder: decodeToInsertCartridgePayloadProxyInput,
        exporter: exportToInsertCartridgePayloadProxy,
        validator: ajv.compile<ifaces.InsertCartridgePayloadProxy>(JSON.parse('{"title": "InsertCartridgePayloadProxy", "type": "object", "properties": {"data": {"type": "string", "format": "binary"}}, "required": ["data"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'SetUnlockedCartridgePayloadProxy': {
        ioType:IOType.mutationPayload,
        abiTypes:['bytes32[]', 'bool[]'],
        params:['ids', 'unlocks'],
        decoder: decodeToSetUnlockedCartridgePayloadProxyInput,
        exporter: exportToSetUnlockedCartridgePayloadProxy,
        validator: ajv.compile<ifaces.SetUnlockedCartridgePayloadProxy>(JSON.parse('{"title": "SetUnlockedCartridgePayloadProxy", "type": "object", "properties": {"ids": {"type": "array", "items": {"type": "string", "format": "binary"}}, "unlocks": {"type": "array", "items": {"type": "boolean"}}}, "required": ["ids", "unlocks"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'RemoveCartridgePayloadProxy': {
        ioType:IOType.mutationPayload,
        abiTypes:['bytes32'],
        params:['id'],
        decoder: decodeToRemoveCartridgePayloadProxyInput,
        exporter: exportToRemoveCartridgePayloadProxy,
        validator: ajv.compile<ifaces.RemoveCartridgePayloadProxy>(JSON.parse('{"title": "RemoveCartridgePayloadProxy", "type": "object", "properties": {"id": {"type": "string", "format": "binary"}}, "required": ["id"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'TransferCartridgePayloadProxy': {
        ioType:IOType.mutationPayload,
        abiTypes:['bytes32', 'address'],
        params:['id', 'new_user_address'],
        decoder: decodeToTransferCartridgePayloadProxyInput,
        exporter: exportToTransferCartridgePayloadProxy,
        validator: ajv.compile<ifaces.TransferCartridgePayloadProxy>(JSON.parse('{"title": "TransferCartridgePayloadProxy", "type": "object", "properties": {"id": {"type": "string", "format": "binary"}, "new_user_address": {"type": "string"}}, "required": ["id", "new_user_address"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'RuleDataProxy': {
        ioType:IOType.mutationPayload,
        abiTypes:['bytes32', 'string', 'string', 'string', 'bytes', 'string', 'uint', 'uint', 'string[]', 'bytes32[]', 'bool', 'bool', 'bool', 'bool'],
        params:['cartridge_id', 'name', 'description', 'args', 'in_card', 'score_function', 'start', 'end', 'tags', 'tapes', 'allow_tapes', 'allow_in_card', 'save_tapes', 'save_out_cards'],
        decoder: decodeToRuleDataProxyInput,
        exporter: exportToRuleDataProxy,
        validator: ajv.compile<ifaces.RuleDataProxy>(JSON.parse('{"title": "RuleDataProxy", "type": "object", "properties": {"cartridge_id": {"type": "string", "format": "binary"}, "name": {"type": "string"}, "description": {"type": "string"}, "args": {"type": "string"}, "in_card": {"type": "string", "format": "binary"}, "score_function": {"type": "string"}, "start": {"type": "integer"}, "end": {"type": "integer"}, "tags": {"type": "array", "items": {"type": "string"}}, "tapes": {"type": "array", "items": {"type": "string", "format": "binary"}}, "allow_tapes": {"type": "boolean"}, "allow_in_card": {"type": "boolean"}, "save_tapes": {"type": "boolean"}, "save_out_cards": {"type": "boolean"}}, "required": ["cartridge_id", "name", "description", "args", "in_card", "score_function", "start", "end", "tags", "tapes", "allow_tapes", "allow_in_card", "save_tapes", "save_out_cards"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'DeactivateRulePayloadProxy': {
        ioType:IOType.mutationPayload,
        abiTypes:['bytes32'],
        params:['rule_id'],
        decoder: decodeToDeactivateRulePayloadProxyInput,
        exporter: exportToDeactivateRulePayloadProxy,
        validator: ajv.compile<ifaces.DeactivateRulePayloadProxy>(JSON.parse('{"title": "DeactivateRulePayloadProxy", "type": "object", "properties": {"rule_id": {"type": "string", "format": "binary"}}, "required": ["rule_id"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'VerifyPayloadProxy': {
        ioType:IOType.mutationPayload,
        abiTypes:['bytes32', 'bytes32', 'bytes', 'int', 'bytes32[]', 'bytes'],
        params:['rule_id', 'outcard_hash', 'tape', 'claimed_score', 'tapes', 'in_card'],
        decoder: decodeToVerifyPayloadProxyInput,
        exporter: exportToVerifyPayloadProxy,
        validator: ajv.compile<ifaces.VerifyPayloadProxy>(JSON.parse('{"title": "VerifyPayloadProxy", "type": "object", "properties": {"rule_id": {"type": "string", "format": "binary"}, "outcard_hash": {"type": "string", "format": "binary"}, "tape": {"type": "string", "format": "binary"}, "claimed_score": {"type": "integer"}, "tapes": {"type": "array", "items": {"type": "string", "format": "binary"}}, "in_card": {"type": "string", "format": "binary"}}, "required": ["rule_id", "outcard_hash", "tape", "claimed_score", "tapes", "in_card"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'ExternalVerificationPayloadProxy': {
        ioType:IOType.mutationPayload,
        abiTypes:['bytes32[]', 'int256[]', 'uint256[]', 'bytes[]'],
        params:['tape_ids', 'scores', 'error_codes', 'outcards'],
        decoder: decodeToExternalVerificationPayloadProxyInput,
        exporter: exportToExternalVerificationPayloadProxy,
        validator: ajv.compile<ifaces.ExternalVerificationPayloadProxy>(JSON.parse('{"title": "ExternalVerificationPayloadProxy", "type": "object", "properties": {"tape_ids": {"type": "array", "items": {"type": "string", "format": "binary"}}, "scores": {"type": "array", "items": {"type": "integer"}}, "error_codes": {"type": "array", "items": {"type": "integer"}}, "outcards": {"type": "array", "items": {"type": "string", "format": "binary"}}}, "required": ["tape_ids", "scores", "error_codes", "outcards"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'AwardWinnerTapesPayloadProxy': {
        ioType:IOType.mutationPayload,
        abiTypes:['bytes32', 'uint'],
        params:['rule_id', 'tapes_to_award'],
        decoder: decodeToAwardWinnerTapesPayloadProxyInput,
        exporter: exportToAwardWinnerTapesPayloadProxy,
        validator: ajv.compile<ifaces.AwardWinnerTapesPayloadProxy>(JSON.parse('{"title": "AwardWinnerTapesPayloadProxy", "type": "object", "properties": {"rule_id": {"type": "string", "format": "binary"}, "tapes_to_award": {"type": "integer"}}, "required": ["rule_id", "tapes_to_award"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'CleanTapesPayloadProxy': {
        ioType:IOType.mutationPayload,
        abiTypes:['bytes32'],
        params:['rule_id'],
        decoder: decodeToCleanTapesPayloadProxyInput,
        exporter: exportToCleanTapesPayloadProxy,
        validator: ajv.compile<ifaces.CleanTapesPayloadProxy>(JSON.parse('{"title": "CleanTapesPayloadProxy", "type": "object", "properties": {"rule_id": {"type": "string", "format": "binary"}}, "required": ["rule_id"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'SetOperatorPayload': {
        ioType:IOType.mutationPayload,
        abiTypes:['address'],
        params:['new_operator_address'],
        decoder: decodeToSetOperatorPayloadInput,
        exporter: exportToSetOperatorPayload,
        validator: ajv.compile<ifaces.SetOperatorPayload>(JSON.parse('{"title": "SetOperatorPayload", "type": "object", "properties": {"new_operator_address": {"type": "string"}}, "required": ["new_operator_address"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'SetLock': {
        ioType:IOType.mutationPayload,
        abiTypes:['bool'],
        params:['lock'],
        decoder: decodeToSetLockInput,
        exporter: exportToSetLock,
        validator: ajv.compile<ifaces.SetLock>(JSON.parse('{"title": "SetLock", "type": "object", "properties": {"lock": {"type": "boolean"}}, "required": ["lock"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'SetMaxLockedCartridges': {
        ioType:IOType.mutationPayload,
        abiTypes:['uint'],
        params:['max_locked_cartridges'],
        decoder: decodeToSetMaxLockedCartridgesInput,
        exporter: exportToSetMaxLockedCartridges,
        validator: ajv.compile<ifaces.SetMaxLockedCartridges>(JSON.parse('{"title": "SetMaxLockedCartridges", "type": "object", "properties": {"max_locked_cartridges": {"type": "integer"}}, "required": ["max_locked_cartridges"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'UpdateRivosPayload': {
        ioType:IOType.mutationPayload,
        abiTypes:['bytes'],
        params:['data'],
        decoder: decodeToUpdateRivosPayloadInput,
        exporter: exportToUpdateRivosPayload,
        validator: ajv.compile<ifaces.UpdateRivosPayload>(JSON.parse('{"title": "UpdateRivosPayload", "type": "object", "properties": {"data": {"type": "string", "format": "binary"}}, "required": ["data"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'CartridgePayloadSplittable': {
        ioType:IOType.queryPayload,
        abiTypes:[],
        params:['id', 'part'],
        decoder: decodeToCartridgePayloadSplittableInput,
        exporter: exportToCartridgePayloadSplittable,
        validator: ajv.compile<ifaces.CartridgePayloadSplittable>(JSON.parse('{"title": "CartridgePayloadSplittable", "type": "object", "properties": {"id": {"type": "string"}, "part": {"type": "integer"}}, "required": ["id"]}'))
    },
    'CartridgePayload': {
        ioType:IOType.queryPayload,
        abiTypes:[],
        params:['id'],
        decoder: decodeToCartridgePayloadInput,
        exporter: exportToCartridgePayload,
        validator: ajv.compile<ifaces.CartridgePayload>(JSON.parse('{"title": "CartridgePayload", "type": "object", "properties": {"id": {"type": "string"}}, "required": ["id"]}'))
    },
    'CartridgesPayload': {
        ioType:IOType.queryPayload,
        abiTypes:[],
        params:['name', 'author', 'tags', 'ids', 'user_address', 'page', 'page_size', 'order_by', 'order_dir', 'get_cover', 'tags_or', 'full', 'enable_inactive', 'enable_non_primary', 'locked'],
        decoder: decodeToCartridgesPayloadInput,
        exporter: exportToCartridgesPayload,
        validator: ajv.compile<ifaces.CartridgesPayload>(JSON.parse('{"title": "CartridgesPayload", "type": "object", "properties": {"name": {"type": "string"}, "author": {"type": "string"}, "tags": {"type": "array", "items": {"type": "string"}}, "ids": {"type": "array", "items": {"type": "string"}}, "user_address": {"type": "string"}, "page": {"type": "integer"}, "page_size": {"type": "integer"}, "order_by": {"type": "string"}, "order_dir": {"type": "string"}, "get_cover": {"type": "boolean"}, "tags_or": {"type": "boolean"}, "full": {"type": "boolean"}, "enable_inactive": {"type": "boolean"}, "enable_non_primary": {"type": "boolean"}, "locked": {"type": "boolean"}}}'))
    },
    'GetCartridgeTagsPayload': {
        ioType:IOType.queryPayload,
        abiTypes:[],
        params:['name'],
        decoder: decodeToGetCartridgeTagsPayloadInput,
        exporter: exportToGetCartridgeTagsPayload,
        validator: ajv.compile<ifaces.GetCartridgeTagsPayload>(JSON.parse('{"title": "GetCartridgeTagsPayload", "type": "object", "properties": {"name": {"type": "string"}}}'))
    },
    'GetCartridgeAuthorsPayload': {
        ioType:IOType.queryPayload,
        abiTypes:[],
        params:['name'],
        decoder: decodeToGetCartridgeAuthorsPayloadInput,
        exporter: exportToGetCartridgeAuthorsPayload,
        validator: ajv.compile<ifaces.GetCartridgeAuthorsPayload>(JSON.parse('{"title": "GetCartridgeAuthorsPayload", "type": "object", "properties": {"name": {"type": "string"}}}'))
    },
    'GetRulesPayload': {
        ioType:IOType.queryPayload,
        abiTypes:[],
        params:['cartridge_id', 'id', 'ids', 'active_ts', 'has_start', 'has_end', 'created_by', 'name', 'page', 'page_size', 'order_by', 'order_dir', 'tags', 'tags_or', 'full', 'enable_deactivated'],
        decoder: decodeToGetRulesPayloadInput,
        exporter: exportToGetRulesPayload,
        validator: ajv.compile<ifaces.GetRulesPayload>(JSON.parse('{"title": "GetRulesPayload", "type": "object", "properties": {"cartridge_id": {"type": "string"}, "id": {"type": "string"}, "ids": {"type": "array", "items": {"type": "string"}}, "active_ts": {"type": "integer"}, "has_start": {"type": "boolean"}, "has_end": {"type": "boolean"}, "created_by": {"type": "string"}, "name": {"type": "string"}, "page": {"type": "integer"}, "page_size": {"type": "integer"}, "order_by": {"type": "string"}, "order_dir": {"type": "string"}, "tags": {"type": "array", "items": {"type": "string"}}, "tags_or": {"type": "boolean"}, "full": {"type": "boolean"}, "enable_deactivated": {"type": "boolean"}}}'))
    },
    'GetRuleTagsPayload': {
        ioType:IOType.queryPayload,
        abiTypes:[],
        params:['name', 'cartridge_id'],
        decoder: decodeToGetRuleTagsPayloadInput,
        exporter: exportToGetRuleTagsPayload,
        validator: ajv.compile<ifaces.GetRuleTagsPayload>(JSON.parse('{"title": "GetRuleTagsPayload", "type": "object", "properties": {"name": {"type": "string"}, "cartridge_id": {"type": "string"}}}'))
    },
    'GetTapesPayload': {
        ioType:IOType.queryPayload,
        abiTypes:[],
        params:['cartridge_id', 'rule_id', 'id', 'user_address', 'ids', 'timestamp_lte', 'timestamp_gte', 'rank_lte', 'rank_gte', 'page', 'page_size', 'order_by', 'order_dir', 'tags', 'tags_or', 'full'],
        decoder: decodeToGetTapesPayloadInput,
        exporter: exportToGetTapesPayload,
        validator: ajv.compile<ifaces.GetTapesPayload>(JSON.parse('{"title": "GetTapesPayload", "type": "object", "properties": {"cartridge_id": {"type": "string"}, "rule_id": {"type": "string"}, "id": {"type": "string"}, "user_address": {"type": "string"}, "ids": {"type": "array", "items": {"type": "string"}}, "timestamp_lte": {"type": "integer"}, "timestamp_gte": {"type": "integer"}, "rank_lte": {"type": "integer"}, "rank_gte": {"type": "integer"}, "page": {"type": "integer"}, "page_size": {"type": "integer"}, "order_by": {"type": "string"}, "order_dir": {"type": "string"}, "tags": {"type": "array", "items": {"type": "string"}}, "tags_or": {"type": "boolean"}, "full": {"type": "boolean"}}}'))
    },
    'FormatInCardPayload': {
        ioType:IOType.queryPayload,
        abiTypes:[],
        params:['rule_id', 'cartridge_id', 'in_card', 'tapes'],
        decoder: decodeToFormatInCardPayloadInput,
        exporter: exportToFormatInCardPayload,
        validator: ajv.compile<ifaces.FormatInCardPayload>(JSON.parse('{"title": "FormatInCardPayload", "type": "object", "properties": {"rule_id": {"type": "string"}, "cartridge_id": {"type": "string"}, "in_card": {"type": "string"}, "tapes": {"type": "array", "items": {"type": "string"}}}}'))
    },
    'EmptyClass': {
        ioType:IOType.queryPayload,
        abiTypes:[],
        params:[],
        decoder: decodeToEmptyClassInput,
        exporter: exportToEmptyClass,
        validator: ajv.compile<ifaces.EmptyClass>(JSON.parse('{"title": "EmptyClass", "type": "object", "properties": {}}'))
    },
    'CartridgeInfo': {
        ioType:IOType.report,
        abiTypes:[],
        params:['id', 'name', 'user_address', 'input_index', 'authors', 'info', 'original_info', 'created_at', 'updated_at', 'cover', 'active', 'unlocked', 'primary', 'primary_id', 'last_version', 'versions', 'tapes', 'tags'],
        decoder: decodeToCartridgeInfo,
        validator: ajv.compile<ifaces.CartridgeInfo>(JSON.parse('{"title": "CartridgeInfo", "type": "object", "properties": {"id": {"type": "string"}, "name": {"type": "string"}, "user_address": {"type": "string"}, "input_index": {"type": "integer"}, "authors": {"type": "array", "items": {"type": "string"}}, "info": {"$ref": "#/definitions/InfoCartridge"}, "original_info": {"$ref": "#/definitions/InfoCartridge"}, "created_at": {"type": "integer"}, "updated_at": {"type": "integer"}, "cover": {"type": "string"}, "active": {"type": "boolean"}, "unlocked": {"type": "boolean"}, "primary": {"type": "boolean"}, "primary_id": {"type": "string"}, "last_version": {"type": "string"}, "versions": {"type": "array", "items": {"type": "string"}}, "tapes": {"type": "array", "items": {"type": "string"}}, "tags": {"type": "array", "items": {"type": "string"}}}, "required": ["id", "name", "user_address", "created_at", "updated_at"], "definitions": {"Author": {"title": "Author", "type": "object", "properties": {"name": {"type": "string"}, "link": {"type": "string"}}, "required": ["name", "link"]}, "InfoCartridge": {"title": "InfoCartridge", "type": "object", "properties": {"name": {"type": "string"}, "summary": {"type": "string"}, "description": {"type": "string"}, "version": {"type": "string"}, "status": {"type": "string"}, "tags": {"type": "array", "items": {"type": "string"}}, "authors": {"type": "array", "items": {"$ref": "#/definitions/Author"}}, "links": {"type": "array", "items": {"type": "string"}}, "tapes": {"type": "array", "items": {"type": "string"}}}}}}'))
    },
    'CartridgesOutput': {
        ioType:IOType.report,
        abiTypes:[],
        params:['data', 'total', 'page'],
        decoder: decodeToCartridgesOutput,
        validator: ajv.compile<ifaces.CartridgesOutput>(JSON.parse('{"title": "CartridgesOutput", "type": "object", "properties": {"data": {"type": "array", "items": {"$ref": "#/definitions/CartridgeInfo"}}, "total": {"type": "integer"}, "page": {"type": "integer"}}, "required": ["data", "total", "page"], "definitions": {"Author": {"title": "Author", "type": "object", "properties": {"name": {"type": "string"}, "link": {"type": "string"}}, "required": ["name", "link"]}, "InfoCartridge": {"title": "InfoCartridge", "type": "object", "properties": {"name": {"type": "string"}, "summary": {"type": "string"}, "description": {"type": "string"}, "version": {"type": "string"}, "status": {"type": "string"}, "tags": {"type": "array", "items": {"type": "string"}}, "authors": {"type": "array", "items": {"$ref": "#/definitions/Author"}}, "links": {"type": "array", "items": {"type": "string"}}, "tapes": {"type": "array", "items": {"type": "string"}}}}, "CartridgeInfo": {"title": "CartridgeInfo", "type": "object", "properties": {"id": {"type": "string"}, "name": {"type": "string"}, "user_address": {"type": "string"}, "input_index": {"type": "integer"}, "authors": {"type": "array", "items": {"type": "string"}}, "info": {"$ref": "#/definitions/InfoCartridge"}, "original_info": {"$ref": "#/definitions/InfoCartridge"}, "created_at": {"type": "integer"}, "updated_at": {"type": "integer"}, "cover": {"type": "string"}, "active": {"type": "boolean"}, "unlocked": {"type": "boolean"}, "primary": {"type": "boolean"}, "primary_id": {"type": "string"}, "last_version": {"type": "string"}, "versions": {"type": "array", "items": {"type": "string"}}, "tapes": {"type": "array", "items": {"type": "string"}}, "tags": {"type": "array", "items": {"type": "string"}}}, "required": ["id", "name", "user_address", "created_at", "updated_at"]}}}'))
    },
    'CartridgeTagsOutput': {
        ioType:IOType.report,
        abiTypes:[],
        params:['tags'],
        decoder: decodeToCartridgeTagsOutput,
        validator: ajv.compile<ifaces.CartridgeTagsOutput>(JSON.parse('{"title": "CartridgeTagsOutput", "type": "object", "properties": {"tags": {"type": "array", "items": {"type": "string"}}}, "required": ["tags"]}'))
    },
    'CartridgeAuthorsOutput': {
        ioType:IOType.report,
        abiTypes:[],
        params:['authors'],
        decoder: decodeToCartridgeAuthorsOutput,
        validator: ajv.compile<ifaces.CartridgeAuthorsOutput>(JSON.parse('{"title": "CartridgeAuthorsOutput", "type": "object", "properties": {"authors": {"type": "array", "items": {"type": "string"}}}, "required": ["authors"]}'))
    },
    'RulesOutput': {
        ioType:IOType.report,
        abiTypes:[],
        params:['data', 'total', 'page'],
        decoder: decodeToRulesOutput,
        validator: ajv.compile<ifaces.RulesOutput>(JSON.parse('{"title": "RulesOutput", "type": "object", "properties": {"data": {"type": "array", "items": {"$ref": "#/definitions/RuleInfo"}}, "total": {"type": "integer"}, "page": {"type": "integer"}}, "required": ["data", "total", "page"], "definitions": {"RuleInfo": {"title": "RuleInfo", "type": "object", "properties": {"id": {"type": "string"}, "name": {"type": "string"}, "description": {"type": "string"}, "cartridge_id": {"type": "string"}, "created_by": {"type": "string"}, "created_at": {"type": "integer"}, "input_index": {"type": "integer"}, "args": {"type": "string"}, "in_card": {"type": "string", "format": "binary"}, "score_function": {"type": "string"}, "start": {"type": "integer"}, "end": {"type": "integer"}, "tags": {"type": "array", "items": {"type": "string"}}, "allow_tapes": {"type": "boolean"}, "allow_in_card": {"type": "boolean"}, "save_tapes": {"type": "boolean"}, "save_out_cards": {"type": "boolean"}, "tapes": {"type": "array", "items": {"type": "string"}}, "deactivated": {"type": "boolean"}}, "required": ["id", "name", "description", "cartridge_id", "created_by", "created_at", "args", "in_card", "score_function", "tags"]}}}'))
    },
    'RuleTagsOutput': {
        ioType:IOType.report,
        abiTypes:[],
        params:['tags'],
        decoder: decodeToRuleTagsOutput,
        validator: ajv.compile<ifaces.RuleTagsOutput>(JSON.parse('{"title": "RuleTagsOutput", "type": "object", "properties": {"tags": {"type": "array", "items": {"type": "string"}}}, "required": ["tags"]}'))
    },
    'TapesOutput': {
        ioType:IOType.report,
        abiTypes:[],
        params:['data', 'total', 'page'],
        decoder: decodeToTapesOutput,
        validator: ajv.compile<ifaces.TapesOutput>(JSON.parse('{"title": "TapesOutput", "type": "object", "properties": {"data": {"type": "array", "items": {"$ref": "#/definitions/TapeInfo"}}, "total": {"type": "integer"}, "page": {"type": "integer"}}, "required": ["data", "total", "page"], "definitions": {"TapeInfo": {"title": "TapeInfo", "type": "object", "properties": {"id": {"type": "string"}, "cartridge_id": {"type": "string"}, "rule_id": {"type": "string"}, "user_address": {"type": "string"}, "timestamp": {"type": "integer"}, "input_index": {"type": "integer"}, "score": {"type": "integer"}, "rank": {"type": "integer"}, "verified": {"type": "boolean"}, "in_card": {"type": "string", "format": "binary"}, "data": {"type": "string", "format": "binary"}, "out_card": {"type": "string", "format": "binary"}, "tapes": {"type": "array", "items": {"type": "string"}}}, "required": ["id", "cartridge_id", "rule_id", "user_address", "timestamp"]}}}'))
    },
    'CartridgeEvent': {
        ioType:IOType.notice,
        abiTypes:['bytes32', 'bytes32', 'int', 'address', 'uint'],
        params:['version', 'cartridge_id', 'cartridge_input_index', 'cartridge_user_address', 'timestamp'],
        decoder: decodeToCartridgeEvent,
        validator: ajv.compile<ifaces.CartridgeEvent>(JSON.parse('{"title": "CartridgeEvent", "type": "object", "properties": {"version": {"type": "string", "format": "binary"}, "cartridge_id": {"type": "string", "format": "binary"}, "cartridge_input_index": {"type": "integer"}, "cartridge_user_address": {"type": "string"}, "timestamp": {"type": "integer"}}, "required": ["version", "cartridge_id", "cartridge_input_index", "cartridge_user_address", "timestamp"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'CartridgeRemoved': {
        ioType:IOType.notice,
        abiTypes:['bytes32', 'uint'],
        params:['cartridge_id', 'timestamp'],
        decoder: decodeToCartridgeRemoved,
        validator: ajv.compile<ifaces.CartridgeRemoved>(JSON.parse('{"title": "CartridgeRemoved", "type": "object", "properties": {"cartridge_id": {"type": "string", "format": "binary"}, "timestamp": {"type": "integer"}}, "required": ["cartridge_id", "timestamp"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'RuleCreated': {
        ioType:IOType.notice,
        abiTypes:['bytes32', 'string', 'uint'],
        params:['rule_id', 'created_by', 'created_at'],
        decoder: decodeToRuleCreated,
        validator: ajv.compile<ifaces.RuleCreated>(JSON.parse('{"title": "RuleCreated", "type": "object", "properties": {"rule_id": {"type": "string", "format": "binary"}, "created_by": {"type": "string"}, "created_at": {"type": "integer"}}, "required": ["rule_id", "created_by", "created_at"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'VerificationOutput': {
        ioType:IOType.notice,
        abiTypes:['bytes32', 'bytes32', 'int', 'address', 'address', 'uint', 'int', 'bytes32', 'int', 'bytes32', 'int', 'uint', 'bytes32[]'],
        params:['version', 'cartridge_id', 'cartridge_input_index', 'cartridge_user_address', 'user_address', 'timestamp', 'score', 'rule_id', 'rule_input_index', 'tape_id', 'tape_input_index', 'error_code', 'tapes'],
        decoder: decodeToVerificationOutput,
        validator: ajv.compile<ifaces.VerificationOutput>(JSON.parse('{"title": "VerificationOutput", "type": "object", "properties": {"version": {"type": "string", "format": "binary"}, "cartridge_id": {"type": "string", "format": "binary"}, "cartridge_input_index": {"type": "integer"}, "cartridge_user_address": {"type": "string"}, "user_address": {"type": "string"}, "timestamp": {"type": "integer"}, "score": {"type": "integer"}, "rule_id": {"type": "string", "format": "binary"}, "rule_input_index": {"type": "integer"}, "tape_id": {"type": "string", "format": "binary"}, "tape_input_index": {"type": "integer"}, "error_code": {"type": "integer"}, "tapes": {"type": "array", "items": {"type": "string", "format": "binary"}}}, "required": ["version", "cartridge_id", "cartridge_input_index", "cartridge_user_address", "user_address", "timestamp", "score", "rule_id", "rule_input_index", "tape_id", "tape_input_index", "error_code", "tapes"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'TapeAward': {
        ioType:IOType.notice,
        abiTypes:['bytes32', 'bytes32', 'int', 'address', 'address', 'uint', 'int', 'bytes32', 'int', 'bytes32', 'int', 'uint'],
        params:['version', 'cartridge_id', 'cartridge_input_index', 'cartridge_user_address', 'user_address', 'timestamp', 'score', 'rule_id', 'rule_input_index', 'tape_id', 'tape_input_index', 'rank'],
        decoder: decodeToTapeAward,
        validator: ajv.compile<ifaces.TapeAward>(JSON.parse('{"title": "TapeAward", "type": "object", "properties": {"version": {"type": "string", "format": "binary"}, "cartridge_id": {"type": "string", "format": "binary"}, "cartridge_input_index": {"type": "integer"}, "cartridge_user_address": {"type": "string"}, "user_address": {"type": "string"}, "timestamp": {"type": "integer"}, "score": {"type": "integer"}, "rule_id": {"type": "string", "format": "binary"}, "rule_input_index": {"type": "integer"}, "tape_id": {"type": "string", "format": "binary"}, "tape_input_index": {"type": "integer"}, "rank": {"type": "integer"}}, "required": ["version", "cartridge_id", "cartridge_input_index", "cartridge_user_address", "user_address", "timestamp", "score", "rule_id", "rule_input_index", "tape_id", "tape_input_index", "rank"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    };